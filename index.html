<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DokuParserJS Demo</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            max-width: 1200px;
            margin-left: auto;
            margin-right: auto;
        }
        h1, h2, h3 {
            color: #333;
        }
        .container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }
        .input-section, .output-section {
            flex: 1;
            min-width: 300px;
        }
        textarea {
            width: 100%;
            height: 200px;
            font-family: monospace;
            font-size: 14px;
            padding: 10px;
        }
        button {
            margin: 10px 0;
            padding: 10px 20px;
            background-color: #007bff;
            color: white;
            border: none;
            cursor: pointer;
        }
        button:hover {
            background-color: #0056b3;
        }
        .output-section {
            border: 1px solid #ccc;
            padding: 10px;
            background-color: #f9f9f9;
        }
        .sample-button {
            margin-right: 10px;
            margin-bottom: 10px;
        }
        pre {
            background-color: #eee;
            padding: 10px;
            overflow-x: auto;
        }
        table.inline {
            border-collapse: collapse;
            width: 100%;
        }
        table.inline td, table.inline th {
            border: 1px solid #ccc;
            padding: 8px;
        }
        table.inline th {
            background-color: #f2f2f2;
        }
        .leftalign { text-align: left; }
        .centeralign { text-align: center; }
        .rightalign { text-align: right; }
        ul, ol {
            margin: 10px 0;
            padding-left: 20px;
        }
        li.level1 { margin-left: 20px; }
        li.level2 { margin-left: 40px; }
        li.level3 { margin-left: 60px; }
        blockquote {
            border-left: 4px solid #ccc;
            margin: 10px 0;
            padding: 0 10px;
        }
        .footnotes {
            margin-top: 20px;
            font-size: 0.9em;
        }
        .fn_bot {
            text-decoration: none;
            color: #007bff;
        }
        .media {
            max-width: 100%;
            height: auto;
        }
        .mediacenter { display: block; margin: 0 auto; }
        .medialeft { float: left; margin-right: 10px; }
        .mediaright { float: right; margin-left: 10px; }
    </style>
</head>
<body>
    <h1>DokuParserJS Demo (Version 49)</h1>
    <p>This page demonstrates the <code>DokuParserJS</code> parser for DokuWiki markup. Enter your own markup or load sample inputs to see the parsed HTML output.</p>

    <div class="container">
        <div class="input-section">
            <h2>Input DokuWiki Markup</h2>
            <button class="sample-button" onclick="loadSample(1)">Load Sample 1</button>
            <button class="sample-button" onclick="loadSample(2)">Load Sample 2</button>
            <textarea id="input" placeholder="Enter DokuWiki markup here..."></textarea>
            <button onclick="parseInput()">Parse</button>
        </div>
        <div class="output-section">
            <h2>Parsed HTML Output</h2>
            <div id="preview"></div>
        </div>
    </div>

    <script>
        // DokuParserJS (Version 49) - Copied from the provided code
        class DokuParserJS {
            constructor(options = {}) {
                this.currentNamespace = (options.currentNamespace || '').replace(/^:+|:+$/g, '');
                this.interwikiMap = options.interwikiMap || {
                    wp: 'https://en.wikipedia.org/wiki/',
                    doku: 'https://www.dokuwiki.org/'
                };
                this.htmlok = options.htmlok !== false;
                this.typography = options.typography !== false;
                this.mediaBasePath = options.mediaBasePath?.trim()
                    ? options.mediaBasePath.replace(/\/+$/, '') + '/' : '/data/media/';
                this.pagesBasePath = options.pagesBasePath?.trim()
                    ? options.pagesBasePath.replace(/\/+$/, '') + '/' : '/data/pages/';
                this.useTxtExtension = options.useTxtExtension || false;
                this.useDokuWikiPaths = options.useDokuWikiPaths || false;
                this.footnotes = [];
                this.footnoteContent = new Map();
                this.linkPlaceholders = [];
                this.nowikiPlaceholders = [];
                this.listStack = [];
                this.currentIndent = -1;
                this.currentType = null;
                this.currentSection = '';
                this.smileyMap = {
                    '8-)': 'üòé',
                    '8-O': 'üò≤',
                    ':-(': 'üò¢',
                    ':-)': 'üôÇ',
                    '=-)': 'üòä',
                    ':-/': 'üòï',
                    ':-\\': 'üòï',
                    ':-D': 'üòÑ',
                    ':-P': 'üòõ',
                    ':-O': 'üòØ',
                    ':-X': 'üò£',
                    ':-|': 'üòê',
                    ';-)': 'üòâ',
                    '^_^': 'üòÑ',
                    ':?:': '‚ùì',
                    ':!:': '‚ùó',
                    'LOL': 'üòÇ',
                    'FIXME': 'üîß',
                    'DELETEME': 'üóëÔ∏è'
                };
                this.rules = [
                    { pattern: /~~(?:NOTOC|NOCACHE)~~/g, replace: '' },
                    { pattern: /~~INFO:syntaxplugins~~/g, replace: '~~INFO:syntaxplugins~~' },
                    { pattern: /(^|\s)8-\)(?=\s|$)/g, replace: '$1üòé' },
                    { pattern: /(^|\s)8-O(?=\s|$)/g, replace: '$1üò≤' },
                    { pattern: /(^|\s):-?\((?=\s|$)/g, replace: '$1üò¢' },
                    { pattern: /(^|\s):-?\)(?=\s|$)/g, replace: '$1üôÇ' },
                    { pattern: /(^|\s)=-\)(?=\s|$)/g, replace: '$1üòä' },
                    { pattern: /(^|\s):-?\/(?=\s|$)(?!\S*:\/\/)/g, replace: '$1üòï' },
                    { pattern: /(^|\s):-?\\(?=\s|$)/g, replace: '$1üòï' },
                    { pattern: /(^|\s):-?D(?=\s|$)/g, replace: '$1üòÑ' },
                    { pattern: /(^|\s):-?P(?=\s|$)/g, replace: '$1üòõ' },
                    { pattern: /(^|\s):-?O(?=\s|$)/g, replace: '$1üòØ' },
                    { pattern: /(^|\s):-?X(?=\s|$)/g, replace: '$1üò£' },
                    { pattern: /(^|\s):-?\|(?=\s|$)/g, replace: '$1üòê' },
                    { pattern: /(^|\s);-\)(?=\s|$)/g, replace: '$1üòâ' },
                    { pattern: /(^|\s)\^_\^(?=\s|$)/g, replace: '$1üòÑ' },
                    { pattern: /(^|\s):?\?:(?=\s|$)/g, replace: '$1‚ùì' },
                    { pattern: /(^|\s):!:(?=\s|$)/g, replace: '$1‚ùó' },
                    { pattern: /(^|\s)LOL(?=\s|$)/g, replace: '$1üòÇ' },
                    { pattern: /(^|\s)FIXME(?=\s|$)/g, replace: '$1üîß' },
                    { pattern: /(^|\s)DELETEME(?=\s|$)/g, replace: '$1üóëÔ∏è' },
                    {
                        pattern: /<nowiki>([\s\S]*?)<\/nowiki>/g,
                        replace: (match, content) => {
                            const ph = `[NOWIKI_${this.nowikiPlaceholders.length}]`;
                            this.nowikiPlaceholders.push(content);
                            return ph;
                        }
                    },
                    {
                        pattern: /%%([\s\S]*?)%%/g,
                        replace: (match, content) => {
                            content = content.trim();
                            if (this.currentSection.match(/^(Code Blocks|Downloadable Code Blocks)$/i)) {
                                return this.escapeEntities(content);
                            }
                            if (this.currentSection.match(/^Text to Image Conversions$/i)) {
                                const smiley = this.smileyMap[content];
                                return `${smiley || content} %% ${content} %%`;
                            }
                            return this.escapeEntities(content);
                        }
                    },
                    {
                        pattern: /\{\{(\s*)([^|{}]*?)(?:\?([^|]*?))?(?:\|(.+?)?)?(\s*)\}\}/g,
                        replace: (match, leadingSpace, src, params, alt, trailingSpace) => {
                            try {
                                if (src.startsWith('rss>')) return '';
                                let className = '';
                                if (!leadingSpace && !trailingSpace) className = 'mediacenter';
                                else if (leadingSpace && !trailingSpace) className = 'mediaright';
                                else if (!leadingSpace && trailingSpace) className = 'medialeft';
                                src = src.trim();
                                let width = '', height = '', isLinkOnly = false, isNoLink = false;
                                if (params) {
                                    const paramList = params.split('&');
                                    paramList.forEach(param => {
                                        if (param.match(/^\d+$/)) width = param;
                                        else if (param.match(/^\d+x\d+$/)) [width, height] = param.split('x');
                                        else if (param === 'linkonly') isLinkOnly = true;
                                        else if (param === 'nolink') isNoLink = true;
                                    });
                                }
                                let resolvedSrc, filename;
                                if (!src.match(/^https?:\/\//)) {
                                    const parts = src.split(':');
                                    filename = parts.pop();
                                    const namespace = parts.join(':').replace(/^:/, '');
                                    resolvedSrc = this.resolveNamespace(namespace, '', true);
                                    if (this.useDokuWikiPaths) {
                                        src = `/lib/exe/fetch.php?media=${resolvedSrc ? encodeURIComponent(resolvedSrc) + ':' : ''}${encodeURIComponent(filename)}`;
                                    } else {
                                        src = this.mediaBasePath + (resolvedSrc ? resolvedSrc.split(':').map(encodeURIComponent).join('/') + '/' : '') + encodeURIComponent(filename);
                                    }
                                } else {
                                    filename = src.split('/').pop();
                                    src = src;
                                }
                                if (isLinkOnly) {
                                    return `<a href="${src}" class="media" rel="nofollow">${alt || decodeURIComponent(filename)}</a>`;
                                }
                                const widthAttr = width ? ` width="${width}"` : '';
                                const heightAttr = height ? ` height="${height}"` : '';
                                const altAttr = alt ? ` alt="${alt}" title="${alt}"` : '';
                                const classAttr = className ? ` class="${className}"` : '';
                                const imgTag = `<img src="${src}"${widthAttr}${heightAttr}${altAttr}${classAttr} loading="lazy">`;
                                return isNoLink ? imgTag : `<a href="${src}" class="media">${imgTag}</a>`;
                            } catch (e) {
                                console.error(`Error processing image: ${match}, error: ${e.message}`);
                                return this.escapeEntities(match);
                            }
                        }
                    },
                    {
                        pattern: /\[\[(.+?)(?:\|(.+?))?\]\]/g,
                        replace: (match, target, text) => {
                            target = target.trim();
                            text = text ? text.trim() : '';
                            if (text && text.match(/\{\{.*\}\}/)) {
                                text = this.applyRules(text);
                                text = text.replace(/<a\s+[^>]*class\s*=\s*"media"[^>]*>([\s\S]*?)<\/a>/g, '$1');
                            }
                            let display = text || target;
                            let href = target;
                            let className = '', attrs = '';
                            const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
                            if (target.match(emailRegex)) {
                                href = `mailto:${target}`;
                                className = 'mail';
                                attrs = ` title="${target.replace(/ /g, ' [at] ').replace(/\./g, ' [dot] ')}"`;
                            } else if (target.match(/^https?:\/\//)) {
                                display = text || target.replace(/^https?:\/\//, '').replace(/^www\./, '').replace(/\/$/, '');
                                className = 'urlextern';
                                attrs = ` title="${target}" rel="nofollow"`;
                                href = target;
                            } else if (target.includes('>')) {
                                const [wiki, page] = target.split('>');
                                if (this.interwikiMap[wiki]) {
                                    href = this.interwikiMap[wiki] + encodeURIComponent(page);
                                    display = text || page;
                                    className = `interwiki iw_${wiki}`;
                                    attrs = ` title="${this.interwikiMap[wiki]}${page}" data-wiki-id="${wiki}:${page}"`;
                                } else {
                                    return match;
                                }
                            } else {
                                let [page, section] = target.split('#');
                                let resolvedPage = page ? this.resolveNamespace(page, this.currentNamespace) : '';
                                if (section && !resolvedPage) {
                                    href = `#${section.toLowerCase().replace(/[^a-z0-9]/g, '_')}`;
                                    className = 'wikilink2';
                                    attrs = ` title="${target}" data-wiki-id="${target}" rel="nofollow"`;
                                } else {
                                    resolvedPage = resolvedPage || 'start';
                                    href = this.useDokuWikiPaths
                                        ? `/doku.php?id=${encodeURIComponent(resolvedPage)}${section ? '#' + section.toLowerCase().replace(/[^a-z0-9]/g, '_') : ''}`
                                        : `${this.pagesBasePath}${resolvedPage.split(':').map(encodeURIComponent).join('/')}${this.useTxtExtension ? '.txt' : ''}${section ? '#' + section.toLowerCase().replace(/[^a-z0-9]/g, '_') : ''}`;
                                    className = resolvedPage.endsWith(':start') ? 'wikilink1 curid' : 'wikilink1';
                                    attrs = ` data-wiki-id="${target}"`;
                                    if (section) className = 'wikilink2';
                                }
                            }
                            const placeholder = `[LINK_${this.linkPlaceholders.length}]`;
                            this.linkPlaceholders.push(`<a href="${href}" class="${className}"${attrs}>${display}</a>`);
                            return placeholder;
                        }
                    },
                    { pattern: /\*\*(.+?)\*\*/g, replace: '<strong>$1</strong>' },
                    { pattern: /\/\/(.+?)(?<!:)\/\//g, replace: '<em>$1</em>' },
                    { pattern: /__(.+?)__/g, replace: '<em class="u">$1</em>' },
                    { pattern: /''(.+?)''/g, replace: '<code>$1</code>' },
                    { pattern: /<sub>(.+?)<\/sub>/g, replace: '<sub>$1</sub>' },
                    { pattern: /<sup>(.+?)<\/sup>/g, replace: '<sup>$1</sup>' },
                    { pattern: /<del>(.+?)<\/del>/g, replace: '<del>$1</del>' },
                    {
                        pattern: /<(?:html|HTML)>([\s\S]*?)<\/(?:html|HTML)>/g,
                        replace: (match, content) => this.htmlok ? content : `<pre class="code html">${this.escapeEntities(content)}</pre>`
                    },
                    {
                        pattern: /<(?:php|PHP)>([\s\S]*?)<\/(?:php|PHP)>/g,
                        replace: (match, content) => `<pre class="code php">${this.escapeEntities(content)}</pre>`
                    },
                    ...(this.typography ? [
                        { pattern: /\s->(?=\s)/g, replace: ' &rarr; ' },
                        { pattern: /\s<-(?=\s)/g, replace: ' &larr; ' },
                        { pattern: /\s<->(?=\s)/g, replace: ' &harr; ' },
                        { pattern: /\s=>(?=\s)/g, replace: ' &rArr; ' },
                        { pattern: /\s<=(?=\s)/g, replace: ' &lArr; ' },
                        { pattern: /\s<=>(?=\s)/g, replace: ' &hArr; ' },
                        { pattern: /\s>>(?=\s)/g, replace: ' &raquo; ' },
                        { pattern: /\s<<(?=\s)/g, replace: ' &laquo; ' },
                        { pattern: /\s---(?=\s)/g, replace: ' &mdash; ' },
                        { pattern: /\s--(?=\s)/g, replace: ' &ndash; ' },
                        { pattern: /\(c\)/gi, replace: '&copy;' },
                        { pattern: /\(tm\)/gi, replace: '&trade;' },
                        { pattern: /\(r\)/gi, replace: '&reg;' },
                        { pattern: /(\d+)x(\d+)/g, replace: '$1&times;$2' }
                    ] : [])
                ];
            }

            resolveNamespace(target, currentNamespace, isMedia = false) {
                target = target.trim();
                const originalTarget = target;
                let isStartPage = originalTarget.endsWith(':');
                if (isStartPage) target = target.slice(0, -1);
                let resolved;
                if (target.startsWith(':')) {
                    resolved = target.substring(1);
                } else if (target.startsWith('..')) {
                    let tempTarget = target;
                    let levels = 0;
                    while (tempTarget.startsWith('..')) {
                        if (tempTarget.startsWith('..:')) {
                            tempTarget = tempTarget.substring(3);
                            levels++;
                        } else {
                            tempTarget = tempTarget.substring(2);
                            levels++;
                        }
                    }
                    let nsParts = currentNamespace ? currentNamespace.split(':') : [];
                    while (levels > 0 && nsParts.length > 0) {
                        nsParts.pop();
                        levels--;
                    }
                    let parentNs = nsParts.join(':');
                    resolved = parentNs ? parentNs + ':' + tempTarget : tempTarget;
                } else if (target.startsWith('.')) {
                    let tempTarget = target.substring(target.startsWith('.:') ? 2 : 1);
                    resolved = currentNamespace ? currentNamespace + ':' + tempTarget : tempTarget;
                } else {
                    resolved = isMedia || target.includes(':') ? target : (currentNamespace ? currentNamespace + ':' + target : target);
                }
                resolved = resolved.replace(/:+/g, ':').replace(/^:/, '').replace(/:$/, '');
                if (!isMedia && isStartPage && !resolved.endsWith(':start')) resolved += ':start';
                return resolved;
            }

            parse(doku) {
                let result = [];
                let lines = doku.split('\n').map(line => line.replace(/\s{2,}/g, ' '));
                let tableBuffer = [];
                let tableRowspans = [];
                let tableAlignments = [];
                let quoteLevel = 0;
                let paragraphBuffer = [];
                let inCodeBlock = false;
                let codeBlockBuffer = [];
                let inPre = false;
                let preBuffer = [];
                let codeLang = '';
                let codeFileName = '';
                let inTable = false;
                let inCodeSection = false;
                let codeBlockIndent = -1;
                this.footnotes = [];
                this.footnoteContent = new Map();
                this.linkPlaceholders = [];
                this.nowikiPlaceholders = [];
                this.listStack = [];
                this.currentIndent = -1;
                this.currentType = null;
                this.currentSection = '';

                for (let i = 0; i < lines.length; i++) {
                    let line = lines[i];
                    let trimmed = line.trim();
                    if (!trimmed) {
                        if (inTable) {
                            if (tableBuffer.length > 0) {
                                result.push(`<table class="inline">${tableBuffer.join('')}</table>`);
                                tableBuffer = [];
                                tableRowspans = [];
                                tableAlignments = [];
                                inTable = false;
                            }
                        } else if (inCodeBlock) {
                            codeBlockBuffer.push('');
                            continue;
                        } else if (inPre) {
                            preBuffer.push('');
                            continue;
                        } else if (quoteLevel > 0 || paragraphBuffer.length > 0 || this.listStack.length > 0) {
                            this.flushBlocks(result, tableBuffer, quoteLevel, paragraphBuffer, codeBlockBuffer, tableRowspans, tableAlignments, codeLang, codeFileName);
                            quoteLevel = 0;
                            paragraphBuffer = [];
                        }
                        continue;
                    }
                    const leadingSpaces = line.match(/^(\s*)/)[1];
                    const indent = leadingSpaces.length;
                    // Prioritize list check before paragraph accumulation
                    if (paragraphBuffer.length > 0 && (indent >= 2 || trimmed.match(/^(?:>|={2,6}.*={2,6}|[\^|]|-{4,}|\{\{.*\}\}$)/))) {
                        this.flushBlocks(result, tableBuffer, quoteLevel, paragraphBuffer, codeBlockBuffer, tableRowspans, tableAlignments, codeLang, codeFileName);
                    }
                    if (indent >= 2 && !inCodeBlock && !inTable && trimmed.match(/^[*|-]/)) {
                        if (inTable) {
                            if (tableBuffer.length > 0) {
                                result.push(`<table class="inline">${tableBuffer.join('')}</table>`);
                                tableBuffer = [];
                                tableRowspans = [];
                                tableAlignments = [];
                                inTable = false;
                            }
                        }
                        this.flushBlocks(result, tableBuffer, quoteLevel, paragraphBuffer, codeBlockBuffer, tableRowspans, tableAlignments, codeLang, codeFileName);
                        let content = trimmed.substring(1).trim(); // Remove * or -
                        content = content.replace(/\\\\\s*$/, '');
                        content = content.replace(/\\\\\s+/g, '<br>');
                        content = inCodeSection ? this.escapeEntities(content) : this.applyRules(content);
                        const listType = line[indent] === '*' ? 'ul' : 'ol';
                        const depth = Math.floor(indent / 2);
                        while (this.currentIndent > depth && this.listStack.length > 0) {
                            result.push('</li>');
                            result.push(`</${this.listStack.pop().type}>`);
                            this.currentIndent = this.listStack.length > 0 ? this.listStack[this.listStack.length - 1].indent : -1;
                            this.currentType = this.listStack.length > 0 ? this.listStack[this.listStack.length - 1].type : null;
                        }
                        if (this.currentIndent === -1 || depth > this.currentIndent) {
                            result.push(`<${listType}>`);
                            this.listStack.push({ type: listType, indent: depth });
                            this.currentType = listType;
                            this.currentIndent = depth;
                        } else if (depth === this.currentIndent && this.currentType !== listType) {
                            result.push('</li>');
                            result.push(`</${this.listStack.pop().type}>`);
                            result.push(`<${listType}>`);
                            this.listStack.push({ type: listType, indent: depth });
                            this.currentType = listType;
                        } else if (depth === this.currentIndent) {
                            result.push('</li>');
                        }
                        result.push(`<li class="level${depth}"><div class="li">${content || ''}</div>`);
                        if (i + 1 < lines.length) {
                            const nextLine = lines[i + 1];
                            const nextTrimmed = nextLine.trim();
                            const nextIndent = nextLine.match(/^(\s*)/)[1].length;
                            const nextDepth = Math.floor(nextIndent / 2);
                            if (!nextTrimmed || nextIndent < 2 || !nextTrimmed.match(/^[*|-]/) || nextDepth < depth) {
                                result.push('</li>');
                                if (!nextTrimmed || nextIndent < 2 || nextDepth < depth) {
                                    while (this.listStack.length > 0 && this.currentIndent > (nextTrimmed ? nextDepth : 0)) {
                                        result.push(`</${this.listStack.pop().type}>`);
                                        this.currentIndent = this.listStack.length > 0 ? this.listStack[this.listStack.length - 1].indent : -1;
                                        this.currentType = this.listStack.length > 0 ? this.listStack[this.listStack.length - 1].type : null;
                                    }
                                }
                            }
                        } else {
                            result.push('</li>');
                            while (this.listStack.length > 0) {
                                result.push(`</${this.listStack.pop().type}>`);
                                this.currentIndent = -1;
                                this.currentType = null;
                            }
                        }
                        continue;
                    }
                    if (trimmed.match(/^<code(?:\s+([^\s>]+))?(?:\s+([^\s>]+(?:[\/\\][^\s>]+)*))?\s*>/)) {
                        if (inTable) {
                            if (tableBuffer.length > 0) {
                                result.push(`<table class="inline">${tableBuffer.join('')}</table>`);
                                tableBuffer = [];
                                tableRowspans = [];
                                tableAlignments = [];
                                inTable = false;
                            }
                        }
                        this.flushBlocks(result, tableBuffer, quoteLevel, paragraphBuffer, codeBlockBuffer, tableRowspans, tableAlignments, codeLang, codeFileName);
                        inCodeBlock = true;
                        inCodeSection = this.currentSection.match(/^(Links|Tables|Quoting|No Formatting|Embedding HTML and PHP|Syntax Plugins|Text to Image Conversions)$/i);
                        codeBlockBuffer = [];
                        const match = trimmed.match(/^<code(?:\s+([^\s>]+))?(?:\s+([^\s>]+(?:[\/\\][^\s>]+)*))?\s*>/);
                        codeLang = match[1] || 'code';
                        codeFileName = match[2] || '';
                        if (codeLang === '-') codeLang = 'code';
                        const startIdx = line.indexOf('<code');
                        const contentAfter = line.substring(startIdx + match[0].length);
                        codeBlockBuffer.push(contentAfter);
                        if (trimmed.includes('</code>')) {
                            const beforeClose = contentAfter.substring(0, contentAfter.lastIndexOf('</code>'));
                            codeBlockBuffer[0] = beforeClose;
                            const classAttr = codeLang ? ` class="${codeLang}${codeFileName ? ' ' + codeFileName : ''}"` : '';
                            result.push(`<pre${classAttr}>${this.escapeEntities(codeBlockBuffer.join('\n'))}</pre>`);
                            inCodeBlock = false;
                            codeBlockBuffer = [];
                            codeLang = '';
                            codeFileName = '';
                            inCodeSection = false;
                        }
                        continue;
                    } else if (trimmed.match(/^<file(?:\s+([^\s>]+))?(?:\s+([^\s>]+(?:[\/\\][^\s>]+)*))?\s*>/)) {
                        if (inTable) {
                            if (tableBuffer.length > 0) {
                                result.push(`<table class="inline">${tableBuffer.join('')}</table>`);
                                tableBuffer = [];
                                tableRowspans = [];
                                tableAlignments = [];
                                inTable = false;
                            }
                        }
                        this.flushBlocks(result, tableBuffer, quoteLevel, paragraphBuffer, codeBlockBuffer, tableRowspans, tableAlignments, codeLang, codeFileName);
                        inCodeBlock = true;
                        inCodeSection = this.currentSection.match(/^(Links|Tables|Quoting|No Formatting|Embedding HTML and PHP|Syntax Plugins|Text to Image Conversions)$/i);
                        codeBlockBuffer = [];
                        const match = trimmed.match(/^<file(?:\s+([^\s>]+))?(?:\s+([^\s>]+(?:[\/\\][^\s>]+)*))?\s*>/);
                        codeLang = match[1] ? `file ${match[1]}` : 'file';
                        codeFileName = match[2] || '';
                        const startIdx = line.indexOf('<file');
                        const contentAfter = line.substring(startIdx + match[0].length);
                        codeBlockBuffer.push(contentAfter);
                        if (trimmed.includes('</file>')) {
                            const beforeClose = contentAfter.substring(0, contentAfter.lastIndexOf('</file>'));
                            codeBlockBuffer[0] = beforeClose;
                            const classAttr = codeLang ? ` class="${codeLang}${codeFileName ? ' ' + codeFileName : ''}"` : '';
                            result.push(`<pre${classAttr}>${this.escapeEntities(codeBlockBuffer.join('\n'))}</pre>`);
                            inCodeBlock = false;
                            codeBlockBuffer = [];
                            codeLang = '';
                            codeFileName = '';
                            inCodeSection = false;
                        }
                        continue;
                    } else if (inCodeBlock && (trimmed.endsWith('</code>') || trimmed.endsWith('</file>'))) {
                        const endTag = trimmed.endsWith('</code>') ? '</code>' : '</file>';
                        const beforeClose = line.substring(0, line.lastIndexOf(endTag));
                        codeBlockBuffer.push(beforeClose);
                        const classAttr = codeLang ? ` class="${codeLang}${codeFileName ? ' ' + codeFileName : ''}"` : '';
                        result.push(`<pre${classAttr}>${this.escapeEntities(codeBlockBuffer.join('\n'))}</pre>`);
                        inCodeBlock = false;
                        codeBlockBuffer = [];
                        codeLang = '';
                        codeFileName = '';
                        inCodeSection = false;
                        continue;
                    } else if (inCodeBlock) {
                        codeBlockBuffer.push(line);
                        continue;
                    }
                    if (!inCodeBlock && !inTable && indent >= 2 && (trimmed.match(/^[\^|]/) || !line.match(/^( {2,})([*|-]\s)/))) {
                        if (inTable) {
                            if (tableBuffer.length > 0) {
                                result.push(`<table class="inline">${tableBuffer.join('')}</table>`);
                                tableBuffer = [];
                                tableRowspans = [];
                                tableAlignments = [];
                                inTable = false;
                            }
                        }
                        this.flushBlocks(result, tableBuffer, quoteLevel, paragraphBuffer, codeBlockBuffer, tableRowspans, tableAlignments, codeLang, codeFileName);
                        inPre = true;
                        inCodeSection = this.currentSection.match(/^(Links|Tables|Quoting|No Formatting|Embedding HTML and PHP|Syntax Plugins|Text to Image Conversions)$/i);
                        preBuffer = [line];
                        codeBlockIndent = indent;
                        continue;
                    }
                    if (inPre) {
                        if (indent >= codeBlockIndent && trimmed && !line.match(/^( {2,})([*|-]\s)/)) {
                            preBuffer.push(line);
                            continue;
                        } else {
                            let preContent = preBuffer.map(l => l.replace(/^ {2,}/, '')).join('\n');
                            preContent = this.escapeEntities(preContent);
                            result.push(`<pre class="code">${preContent}</pre>`);
                            inPre = false;
                            preBuffer = [];
                            inCodeSection = false;
                            codeBlockIndent = -1;
                        }
                    }
                    if (i === lines.length - 1 && inPre) {
                        let preContent = preBuffer.map(l => l.replace(/^ {2,}/, '')).join('\n');
                        preContent = this.escapeEntities(preContent);
                        result.push(`<pre class="code">${preContent}</pre>`);
                        inPre = false;
                        inCodeSection = false;
                        codeBlockIndent = -1;
                        continue;
                    }
                    const quoteMatch = line.match(/^(>+)\s*(.*)/);
                    if (quoteMatch) {
                        if (inTable) {
                            if (tableBuffer.length > 0) {
                                result.push(`<table class="inline">${tableBuffer.join('')}</table>`);
                                tableBuffer = [];
                                tableRowspans = [];
                                tableAlignments = [];
                                inTable = false;
                            }
                        }
                        this.flushBlocks(result, tableBuffer, quoteLevel, paragraphBuffer, codeBlockBuffer, tableRowspans, tableAlignments, codeLang, codeFileName);
                        const newLevel = quoteMatch[1].length;
                        const content = quoteMatch[2];
                        let formattedContent = content.trim();
                        formattedContent = formattedContent.replace(/\\\\\s*$/, '');
                        formattedContent = formattedContent.replace(/\\\\\s+/g, '<br>');
                        formattedContent = inCodeSection ? this.escapeEntities(formattedContent) : this.applyRules(formattedContent);
                        while (quoteLevel > newLevel) {
                            result.push('</div></blockquote>');
                            quoteLevel--;
                        }
                        while (quoteLevel < newLevel) {
                            result.push('<blockquote><div class="no">');
                            quoteLevel++;
                        }
                        if (formattedContent) {
                            result.push(formattedContent);
                        }
                        if (i === lines.length - 1 && quoteLevel > 0) {
                            while (quoteLevel > 0) {
                                result.push('</div></blockquote>');
                                quoteLevel--;
                            }
                        }
                        continue;
                    } else if (quoteLevel > 0) {
                        this.flushBlocks(result, tableBuffer, quoteLevel, paragraphBuffer, codeBlockBuffer, tableRowspans, tableAlignments, codeLang, codeFileName);
                        quoteLevel = 0;
                    }
                    if (!inCodeSection && !inPre && trimmed.match(/^[\^|]/)) {
                        if (paragraphBuffer.length > 0 || quoteLevel > 0 || this.listStack.length > 0) {
                            this.flushBlocks(result, tableBuffer, quoteLevel, paragraphBuffer, codeBlockBuffer, tableRowspans, tableAlignments, codeLang, codeFileName);
                            paragraphBuffer = [];
                        }
                        const isHeaderRow = trimmed.match(/^\^/);
                        const sep = isHeaderRow ? '^' : '|';
                        let rawLine = trimmed.substring(1);
                        rawLine = rawLine.endsWith(sep) ? rawLine.slice(0, -1) : rawLine;
                        rawLine = rawLine.replace(/\/\/.*$/, '').trim();
                        let cells = this.splitCells(rawLine, sep);
                        let cellContents = [];
                        let cellTags = [];
                        let alignments = [];
                        try {
                            cells.forEach((cell, index) => {
                                let align = 'leftalign';
                                if (cell.match(/^\s{2,}.*\s{2,}$/)) align = 'centeralign';
                                else if (cell.match(/^\s{2,}/)) align = 'rightalign';
                                else if (cell.match(/\s{2,}$/)) align = 'leftalign';
                                let content = cell.trim();
                                content = content.replace(/\\\\\s*$/, '');
                                content = content.replace(/\\\\\s+/g, '<br>');
                                content = this.applyRules(content);
                                alignments.push(align);
                                cellContents.push(content);
                                cellTags.push(isHeaderRow || (sep === '|' && cell.trim().match(/^\^.*\^$/)) ? 'th' : 'td');
                            });
                            if (isHeaderRow) tableAlignments = alignments;
                            if (!tableRowspans.length || tableRowspans.length < cellContents.length) {
                                tableRowspans = new Array(cellContents.length).fill(0);
                            }
                            let row = `<tr class="row${tableBuffer.length}">`;
                            let cellIndex = 0;
                            let nonEmptyCells = cellContents.filter(c => c !== '' && c !== ':::').length;
                            if (nonEmptyCells === 0) {
                                continue; // Skip empty rows
                            }
                            for (let j = 0; j < cellContents.length;) {
                                if (tableRowspans[j] > 0) {
                                    tableRowspans[j]--;
                                    j++;
                                    continue;
                                }
                                let cell = cellContents[j];
                                let tag = cellTags[j];
                                let colspan = 1;
                                let k = j + 1;
                                while (k < cellContents.length && cellContents[k] === '') {
                                    k++;
                                    colspan++;
                                }
                                let rowspanAttr = '';
                                if (cell === ':::') {
                                    tableRowspans[j]--;
                                    j++;
                                    continue;
                                } else if (cell.match(/^:+$/)) {
                                    const colons = (cell.match(/:/g) || []).length;
                                    rowspanAttr = colons > 1 ? ` rowspan="${colons}"` : '';
                                    tableRowspans[j] = colons - 1;
                                    cell = '';
                                }
                                const alignClass = alignments[j] || (j < tableAlignments.length ? tableAlignments[j] : 'leftalign');
                                const classAttr = alignClass ? ` class="col${cellIndex} ${alignClass}"` : ` class="col${cellIndex}"`;
                                const colspanAttr = colspan > 1 && cell !== '' ? ` colspan="${colspan}"` : '';
                                row += `<${tag}${rowspanAttr}${colspanAttr}${classAttr}>${cell}</${tag}>`;
                                j = k;
                                cellIndex++;
                            }
                            if (cellIndex > 0) {
                                row += '</tr>';
                                tableBuffer.push(row);
                            }
                            inTable = true;
                        } catch (e) {
                            console.error(`Error parsing table at line ${i + 1}: ${e.message}`);
                            if (tableBuffer.length > 0) {
                                result.push(`<table class="inline">${tableBuffer.join('')}</table>`);
                            }
                            tableBuffer = [];
                            tableRowspans = [];
                            tableAlignments = [];
                            inTable = false;
                            continue;
                        }
                        if (i === lines.length - 1 || !lines[i + 1].trim().match(/^[\^|]/)) {
                            if (tableBuffer.length > 0) {
                                result.push(`<table class="inline">${tableBuffer.join('')}</table>`);
                            }
                            tableBuffer = [];
                            tableRowspans = [];
                            tableAlignments = [];
                            inTable = false;
                        }
                        continue;
                    } else if (inCodeSection && trimmed.match(/^[\^|].*[\^|]$/)) {
                        codeBlockBuffer.push(line);
                        if (i === lines.length - 1 || !lines[i + 1].trim().match(/^[\^|]/)) {
                            const classAttr = codeLang ? ` class="${codeLang}${codeFileName ? ' ' + codeFileName : ''}"` : ' class="code"';
                            result.push(`<pre${classAttr}>${this.escapeEntities(codeBlockBuffer.join('\n'))}</pre>`);
                            codeBlockBuffer = [];
                            codeLang = '';
                            codeFileName = '';
                        }
                        continue;
                    }
                    if (inTable && !trimmed.match(/^(?:\s*[\^|].*)$/)) {
                        if (tableBuffer.length > 0) {
                            result.push(`<table class="inline">${tableBuffer.join('')}</table>`);
                            tableBuffer = [];
                            tableRowspans = [];
                            tableAlignments = [];
                            inTable = false;
                        }
                    }
                    if (trimmed.match(/^={2,6}.*={2,6}$/)) {
                        if (inTable) {
                            if (tableBuffer.length > 0) {
                                result.push(`<table class="inline">${tableBuffer.join('')}</table>`);
                                tableBuffer = [];
                                tableRowspans = [];
                                tableAlignments = [];
                                inTable = false;
                            }
                        }
                        this.flushBlocks(result, tableBuffer, quoteLevel, paragraphBuffer, codeBlockBuffer, tableRowspans, tableAlignments, codeLang, codeFileName);
                        const equalsCount = (trimmed.match(/=/g) || []).length / 2;
                        let content = trimmed.replace(/^={2,6}/, '').replace(/={2,6}$/, '').trim();
                        content = this.applyRules(content);
                        const level = Math.max(1, Math.min(6, 6 - Math.floor(equalsCount) + 1));
                        const id = content.toLowerCase().replace(/[^a-z0-9]/g, '_').replace(/_+/g, '_').replace(/^_|_$/g, '');
                        result.push(`<h${level} id="${id}">${content}</h${level}>`);
                        this.currentSection = content;
                        inCodeSection = content.match(/^(Links|Tables|Quoting|No Formatting|Embedding HTML and PHP|Syntax Plugins|Text to Image Conversions)$/i);
                        continue;
                    }
                    if (trimmed.match(/^-{4,}$/)) {
                        if (inTable) {
                            if (tableBuffer.length > 0) {
                                result.push(`<table class="inline">${tableBuffer.join('')}</table>`);
                                tableBuffer = [];
                                tableRowspans = [];
                                tableAlignments = [];
                                inTable = false;
                            }
                        }
                        this.flushBlocks(result, tableBuffer, quoteLevel, paragraphBuffer, codeBlockBuffer, tableRowspans, tableAlignments, codeLang, codeFileName);
                        result.push('<hr>');
                        inCodeSection = false;
                        continue;
                    }
                    if (trimmed.match(/^\{\{.*\}\}$/) && !trimmed.match(/^\{\{rss>/)) {
                        if (inTable) {
                            if (tableBuffer.length > 0) {
                                result.push(`<table class="inline">${tableBuffer.join('')}</table>`);
                                tableBuffer = [];
                                tableRowspans = [];
                                tableAlignments = [];
                                inTable = false;
                            }
                        }
                        this.flushBlocks(result, tableBuffer, quoteLevel, paragraphBuffer, codeBlockBuffer, tableRowspans, tableAlignments, codeLang, codeFileName);
                        let content = this.applyRules(trimmed);
                        result.push(`<p>${content}</p>`);
                        continue;
                    }
                    if (!inCodeSection && !inTable && !quoteMatch && !trimmed.match(/^[\^|]/) && !trimmed.match(/^={2,6}.*={2,6}$/) && !trimmed.match(/^-{4,}$/) && !trimmed.match(/^\{\{.*\}\}$/)) {
                        let content = trimmed;
                        content = content.replace(/\\\\\s*$/, '');
                        content = content.replace(/\\\\\s+/g, '<br>');
                        content = inCodeSection ? this.escapeEntities(content) : this.applyRules(content);
                        paragraphBuffer.push(content);
                        if (i === lines.length - 1 || (lines[i + 1] && lines[i + 1].trim().match(/^(?:>|={2,6}.*={2,6}|[\^|]|-{4,}|\{\{.*\}\}$)/))) {
                            this.flushBlocks(result, tableBuffer, quoteLevel, paragraphBuffer, codeBlockBuffer, tableRowspans, tableAlignments, codeLang, codeFileName);
                            paragraphBuffer = [];
                        }
                        continue;
                    }
                }
                this.flushBlocks(result, tableBuffer, quoteLevel, paragraphBuffer, codeBlockBuffer, tableRowspans, tableAlignments, codeLang, codeFileName);
                if (inPre) {
                    let preContent = preBuffer.map(l => l.replace(/^ {2,}/, '')).join('\n');
                    preContent = this.escapeEntities(preContent);
                    result.push(`<pre class="code">${preContent}</pre>`);
                }
                if (this.footnoteContent.size > 0) {
                    result.push('<div class="footnotes">');
                    Array.from(this.footnoteContent.entries()).forEach(([note, index]) => {
                        if (!note.trim()) return;
                        const formattedNote = this.applyRules(note);
                        result.push(`<div class="fn"><sup><a href="#fnt__${index + 1}" id="fn__${index + 1}" class="fn_bot">${index + 1}</a></sup> <div class="content">${formattedNote}</div></div>`);
                    });
                    result.push('</div>');
                }
                let finalResult = result.join('\n');
                this.linkPlaceholders.forEach((link, index) => {
                    finalResult = finalResult.replace(`[LINK_${index}]`, link);
                });
                this.nowikiPlaceholders.forEach((raw, idx) => {
                    finalResult = finalResult.replace(new RegExp(`\\[NOWIKI_${idx}\\]`, 'g'), this.escapeEntities(raw));
                });
                finalResult = `<div class="page group">${finalResult}</div>`;
                return finalResult;
            }

            splitCells(line, sep) {
                let cells = [];
                let currentCell = '';
                let inLink = false;
                let linkDepth = 0;
                let inSmiley = false;
                for (let i = 0; i < line.length; i++) {
                    if (line[i] === '[' && line[i + 1] === '[') {
                        inLink = true;
                        linkDepth++;
                        currentCell += line[i];
                        continue;
                    }
                    if (line[i] === ']' && line[i + 1] === ']' && inLink) {
                        linkDepth--;
                        currentCell += line[i];
                        if (linkDepth === 0) inLink = false;
                        continue;
                    }
                    if (line[i] === ':' && line[i + 1] === '!' && line[i + 2] === ':' && !inLink) {
                        inSmiley = true;
                        currentCell += line[i];
                        continue;
                    }
                    if (line[i] === ':' && inSmiley) {
                        inSmiley = false;
                        currentCell += line[i];
                        continue;
                    }
                    if (line[i] === sep && !inLink && !inSmiley && linkDepth === 0) {
                        cells.push(currentCell);
                        currentCell = '';
                        continue;
                    }
                    currentCell += line[i];
                }
                if (currentCell.trim()) cells.push(currentCell);
                return cells;
            }

            applyRules(content) {
                let result = content;
                this.nowikiPlaceholders = [];
                this.rules.forEach(rule => {
                    result = result.replace(rule.pattern, typeof rule.replace === 'function' ? rule.replace.bind(this) : rule.replace);
                });
                result = this.parseFootnotes(result);
                return result;
            }

            parseFootnotes(content) {
                return content.replace(/\(\((.+?)\)\)/g, (match, note) => {
                    if (!note.trim()) return match;
                    let index = this.footnoteContent.get(note);
                    if (index === undefined) {
                        index = this.footnoteContent.size;
                        this.footnoteContent.set(note, index);
                    }
                    return `<sup><a href="#fn__${index + 1}" id="fnt__${index + 1}" class="fn_bot">[${index + 1}]</a></sup>`;
                });
            }

            escapeEntities(content) {
                return content
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#39;');
            }

            flushBlocks(result, tableBuffer, quoteLevel, paragraphBuffer, codeBlockBuffer, tableRowspans, tableAlignments, codeLang = '', codeFileName = '') {
                if (this.listStack.length > 0) {
                    while (this.listStack.length > 0) {
                        result.push('</li>');
                        result.push(`</${this.listStack.pop().type}>`);
                        this.currentIndent = -1;
                        this.currentType = null;
                    }
                }
                if (tableBuffer.length > 0) {
                    result.push(`<table class="inline">${tableBuffer.join('')}</table>`);
                    tableBuffer.length = 0;
                    tableRowspans.length = 0;
                    tableAlignments.length = 0;
                }
                if (quoteLevel > 0) {
                    while (quoteLevel > 0) {
                        result.push('</div></blockquote>');
                        quoteLevel--;
                    }
                }
                if (paragraphBuffer.length > 0) {
                    let paraContent = paragraphBuffer.join(' ');
                    if (paraContent.trim()) {
                        result.push(`<p>${paraContent}</p>`);
                    }
                    paragraphBuffer.length = 0;
                }
                if (codeBlockBuffer.length > 0) {
                    const classAttr = codeLang ? ` class="${codeLang}${codeFileName ? ' ' + codeFileName : ''}"` : ' class="code"';
                    result.push(`<pre${classAttr}>${this.escapeEntities(codeBlockBuffer.join('\n'))}</pre>`);
                    codeBlockBuffer.length = 0;
                    codeLang = '';
                    codeFileName = '';
                }
            }
        }

        // Sample inputs
        const sampleInput1 = `
====== Sample Input 1 ======
This is a paragraph with **bold text** and //italic text//. Here's a link: [[http://example.com|Example]].

* Unordered list item 1
  * Nested item 1.1
  * Nested item 1.2
* Unordered list item 2

- Ordered list item 1
  - Nested ordered item 1.1
- Ordered list item 2

| Header 1 | Header 2 |
| Cell 1   | Cell 2   |
|  Center  | Right   |

<code php myexample.php>
<?php
echo "Hello, World!";
?>
</code>

> Quote level 1
>> Quote level 2

{{http://example.com/image.jpg?200|Example Image}}

Text with a footnote ((This is a footnote)).
:!: Warning smiley.
`;

        const sampleInput2 = `
====== Sample Input 2 ======
* Food poisoning...
  * Symptoms include nausea and vomiting
  * Seek medical attention
- Step 1: Stay hydrated
- Step 2: Rest

| ^ Header 1 ^ Header 2 |
| Data 1 | [[http://example.com|Link]] |
| ::: | Continuation |

<code>
# Sample code
print("Test")
</code>

**Bold** and //italic// with :!: smiley.
`;

        // Initialize parser
        const parser = new DokuParserJS();

        // Function to parse input
        function parseInput() {
            const input = document.getElementById('input').value;
            try {
                const output = parser.parse(input);
                document.getElementById('preview').innerHTML = output;
            } catch (e) {
                document.getElementById('preview').innerHTML = `<p style="color: red;">Error parsing input: ${e.message}</p>`;
            }
        }

        // Function to load sample inputs
        function loadSample(sampleNumber) {
            const inputArea = document.getElementById('input');
            inputArea.value = sampleNumber === 1 ? sampleInput1 : sampleInput2;
            parseInput();
        }

        // Parse initial sample on page load
        window.onload = () => {
            loadSample(1);
        };
    </script>
</body>
</html>